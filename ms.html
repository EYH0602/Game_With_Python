<!DOCTYPE html>
<html>
<head>
<title>ms.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E7%AC%AC7%E7%AB%A0-minesweeper">第7章 Minesweeper</h1>
<p>前面几张已经介绍过Pygame模块的基本使用方法，本章将会把重点放在实现扫雷游戏的Python语法和算法。
在第6章 Connect 4中，我们介绍了矩阵（二维数组）的结构和基本算法，在这章则会接触矩阵的基本搜素算法。
除此之外，本章将会介绍一些在应用方便的基础知识，比如应用广泛的JSON文件和正则表达式</p>
<!---和匿名函数--->
<p>我们在Minesweeper游戏将要涉及的几个功能如下:</p>
<ul>
<li>元组</li>
<li>Pygame 通过鼠标的人机交互</li>
<li>文件处理</li>
<li>JSON文件</li>
<li>正则表达式 Regular Expression</li>
<li>二维数组的深度优先搜索</li>
</ul>
<!---* 匿名函数 Lambda Expression-->
<h2 id="71-%E5%85%83%E7%BB%84-tuple">7.1 元组 Tuple</h2>
<h3 id="711-tuple-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">7.1.1 Tuple 基本语法</h3>
<p>元组是一种常用的对象类型，很多高层编程语言都有它的身影。
在C++中他叫作pair或是set，在Java中它叫做Tuple。元组的作用其实很简单：表示一组<strong>相关的</strong>数据。
等等，表示一组数据？为什么这句话听起来与第6章学习的list如此相似？
是的，Tuple这种数据类型的应用场景和方式与list的确有很多相似的地方。来看看语法：</p>
<pre class="hljs"><code><div>fruit_tuple = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>) <span class="hljs-comment"># a tuple of fruits</span>
fruit_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]  <span class="hljs-comment"># a list of fruits</span>
</div></code></pre>
<p>Python作为一种高级语言，一个元组所包含的元素类型可以不一样, 也可以有多种创建方法。
在创建元组的时候，Python允许我们使用()来表示这组数据的类型为元组，就像[]表示一组数据为列表一样。
与此同时，Python同样允许我们不写()，同样表示元组。
然而，作者极其不推荐这种写法，因为很多时候这种创建方式的表达意义并不明确，会带来很差的可读性。
要时刻记住，写代码的首要目的是让人能看懂，其次才是让计算机运行</p>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-string">'apple'</span>, <span class="hljs-number">50</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-number">16.7</span>)    <span class="hljs-comment"># 包含不同类型的元素</span>
tup2 = <span class="hljs-string">'apple'</span>, <span class="hljs-number">50</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-number">16.7</span>      <span class="hljs-comment"># 不是使用()创建</span>
tup3 = ()   <span class="hljs-comment"># 创建空元组</span>
tup4 = (<span class="hljs-string">'delicious'</span>,)   <span class="hljs-comment"># 创建只有一个元素的元组，有逗号</span>
tup5 = (<span class="hljs-string">'delicious'</span>)    <span class="hljs-comment"># 创建只有一个元素的元组，无逗号</span>

print(tup1)
print(tup2)
print(tup3)
print(tup4)
print(tup5)
</div></code></pre>
<p>依次打印tup1-tup4, 看看这段代码的运行结果是什么。从运行结果可以看出，tup4和tup5的打印结果
有很大的区别。如果元素只有一个元素，请务必记住要在元素后加上都好','，否则Python解释器会把你的
意思理解为字符串，如同tup5的运行结果：</p>
<pre class="hljs"><code><div>('apple', 50, 'banana', 16.7)
('apple', 50, 'banana', 16.7)
()
('delicious',)
delicious
</div></code></pre>
<p>在了解如何创建元组后，我们需要做的就是访问元组。
访问元组元素的方式与列表类似，通过objName[index]的方式来表示元组中的元素。</p>
<pre class="hljs"><code><div>tup = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>) <span class="hljs-comment"># a tuple of fruits</span>
print(tup)
print(tup[<span class="hljs-number">0</span>])   <span class="hljs-comment"># apple</span>
print(tup[<span class="hljs-number">-2</span>])  <span class="hljs-comment"># orange</span>
print(tup[<span class="hljs-number">1</span>:])  <span class="hljs-comment"># ('banana', 'orange', 'peach')</span>

<span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> tup:
    print(fruit)
</div></code></pre>
<p>运行结果如下：</p>
<pre class="hljs"><code><div>('apple', 'banana', 'orange')
apple
orange
('banana', 'orange', 'peach')
apple
banana
orange
peach
</div></code></pre>
<p>除了简单的创建和访问之外，元组类还支持一些列的基础计算。
Python允许我们使用'+'操作符来合并两个元组，'*'操作符来复制元组的元素：</p>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>)
tup2 = (<span class="hljs-string">'b'</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>)
tup3 = tup1 + tup2
print(tup3) <span class="hljs-comment"># (1, 'a', 2, 'b', 3, 'c')</span>

tup4 = (<span class="hljs-string">'abc'</span>,)*<span class="hljs-number">3</span>
print(tup4) <span class="hljs-comment"># ('abc', 'abc', 'abc')</span>
</div></code></pre>
<p>元组最为Python的一个类，当然要有成员函数。
Python给元组类定义了五个最常用的成员函数：</p>
<ul>
<li>len(tuple)</li>
<li>max(tuple)</li>
<li>min(tuple)</li>
<li>tuple(list)</li>
</ul>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
list1 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]

print(len(tup1))    <span class="hljs-comment"># 3</span>
print(max(tup1))    <span class="hljs-comment"># 3</span>
print(min(tup1))    <span class="hljs-comment"># 1</span>
print(tuple(list1)) <span class="hljs-comment"># (4, 5, 6)</span>
</div></code></pre>
<h3 id="712-tuple%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB">7.1.2 Tuple与List的区别</h3>
<h5 id="1-%E5%8F%AF%E6%9B%B4%E6%94%B9%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9">1. 可更改与不可更改</h5>
<p>通过第6章所学，我们知道如何对列表的元素进行更新。然而，同样的更改在元组是不可行的。
什么意思呢？这就是列表和元组的第一大区别。
在列表类型中，元素的值是可以被更改的；而在元组类型中，元素的之是不可更改的。
因此，我们可以使用元组最为字典的key值，而列表不行。
为了更加直观的体现，让我们用代码尝试一下吧:<br>
列表：</p>
<pre class="hljs"><code><div>fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>]
print(fruits)

fruits[<span class="hljs-number">1</span>] = <span class="hljs-string">'watermelon'</span> <span class="hljs-comment"># 更新fruits列表的第2位元素</span>
print(fruits)
</div></code></pre>
<p>运行结果如下：</p>
<pre class="hljs"><code><div>['apple', 'banana', 'orange', 'peach']
['apple', 'watermelon', 'orange', 'peach']
</div></code></pre>
<p>元组:</p>
<pre class="hljs"><code><div>fruits = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>)
fruits[<span class="hljs-number">1</span>] = <span class="hljs-string">'watermelon'</span> <span class="hljs-comment"># 尝试更新fruits元组的第2位元素</span>
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>Traceback (most recent call last):
  File &quot;try.py&quot;, line 4, in &lt;module&gt;
      fruits[1] = 'watermelon'
      TypeError: 'tuple' object does not support item assignment

      shell returned 1
</div></code></pre>
<p>很明显，Python解释器不允许我们这样做。它也给出了明显的提醒:
TypeError: 'tuple' object does not support item assignment.</p>
<p>不光是元组的元素不可更改，它的长度同样也是不可更改的。
Tuple类甚至都没有给出增加/减少元素的函数:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># continues from the last code block</span>
fruits.append(<span class="hljs-string">'kiwi'</span>)
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>Traceback (most recent call last):
  File &quot;try.py&quot;, line 3, in &lt;module&gt;
      fruits.append('kiwi')
      AttributeError: 'tuple' object has no attribute 'append'

      shell returned 1
</div></code></pre>
<h5 id="2-%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%95%E7%94%A8">2. 复制与引用</h5>
<p>在第6章中，我们学习过函数传递值和传递引用的区别。
同样的思想也在列表与元组的区别中有所体现。
因为元组类型的不可更改性，当你使用tuple(tup_name)函数进行类型转换是，返回值是原元组的引用。
而列表具有可更改该性，list(list_name)的返回值是被复制产生的新列表。</p>
<pre class="hljs"><code><div>fruit_tuple = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>) <span class="hljs-comment"># a tuple of fruits</span>
fruit_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]  <span class="hljs-comment"># a list of fruits</span>

<span class="hljs-comment"># test for tuple</span>
tuple2 = tuple(fruit_tuple)
print(tuple2 <span class="hljs-keyword">is</span> fruit_tuple)

<span class="hljs-comment"># test for list</span>
list2 = list(fruit_list)
print(list2 <span class="hljs-keyword">is</span> fruit_list)
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>True
False
</div></code></pre>
<h5 id="3-%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8">3. 空间占用</h5>
<p>由于元组类型的不可能改性，Python解释器会为其分配更小的内存占用。
因此，当元组和列表包含通函的元素时，元组占用的空间会更小一些。</p>
<pre class="hljs"><code><div><span class="hljs-comment"># continues from the last code block</span>
print(fruit_tuple.__sizeof__())
print(fruit_list.__sizeof__())
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>48
64
</div></code></pre>
<p>综上所述，我们在编写程序时，根据需求来选择使用元组或者列表。
如果无需更改内容，或者需要使内容不可更改，我们会选择使用元组。
比如传递游戏屏幕上的坐标，使用一种颜色，等等。
而当我们需要对内容进行更改是，我们只能选择列表。
比如游戏棋盘。</p>
<h2 id="72-pygame-%E9%80%9A%E8%BF%87%E9%BC%A0%E6%A0%87%E7%9A%84%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92">7.2 Pygame 通过鼠标的人机交互</h2>
<p>在上一章，我们学习了Pygame模块的基础功能，比如设置游戏屏幕，键盘交互，绘制图形等。
在这一章，因为扫雷不能用只用键盘来玩，我们将要学习如何通过鼠标点击与计算机交互。
在讨论通过鼠标的Pygame人机交互以前，我们先来认识一下常规鼠标的构造。
<img src="pics/Logitech M325.jpeg" alt="Logitech M325" title="Logitech M325">
从图片可以看出，普通鼠标的正面（上面）有三个按键。从左到右，把它们标号为1,2,3。</p>
<table>
<thead>
<tr>
<th>键位</th>
<th>代号</th>
</tr>
</thead>
<tbody>
<tr>
<td>左键</td>
<td># 1</td>
</tr>
<tr>
<td>滚轮键</td>
<td># 2</td>
</tr>
<tr>
<td>右键</td>
<td># 3</td>
</tr>
</tbody>
</table>
<p>为什么要定义这三个常用按键的代号呢？因为我们在Pygame中就是以这三个代号称呼他们的
在扫雷游戏中，我们需要用到鼠标的左键和右键，也就是1和3。在取得鼠标信息的过程中，
需要注意到的Pygame功能有2点:</p>
<ul>
<li>pygame.MOUSEBUTTONUP</li>
<li>pygame.mouse.get_pos()</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># 首先定义左键和右键，使得代码可读性更高</span>
LEFT = <span class="hljs-number">1</span>
RIGHT = <span class="hljs-number">3</span>

<span class="hljs-comment"># 引用第6章中获取状态的代码</span>
<span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():
	pos = pygame.mouse.get_pos()
	print(pos)	<span class="hljs-comment"># 打印鼠标点击在游戏屏幕上的坐标</span>
	<span class="hljs-keyword">if</span> event.button == LEFT:
		print(<span class="hljs-string">"Left Click"</span>)
	<span class="hljs-keyword">elif</span> event.button == RIGHT:
		print(<span class="hljs-string">"Right Click"</span>)
</div></code></pre>
<h2 id="73-json">7.3 JSON</h2>
<p>JSON全称叫做JavaScript Object Notation，是一种面对对象的通用表示方法。
JSON这种表示方法具备什么样的特性呢？</p>
<ul>
<li>轻量级<br>
JSON文件本质是文本文件，占用极小的储存空间，读取时占用内存很小</li>
<li>易懂<br>
JSON文件格式可以很好的描述面对对象的程序设计理念，更加直观的说明程序设计API</li>
<li>独立于编程语言<br>
尽管JSON叫做JavaScript Object Notation，但其实并非只能用于JavaScript。
大多数流行的编程语言都有自己的JSON处理模块，
比如Python的json模块，C++的Json::Value库</li>
</ul>
<p>由于这三个特性，JSON经常被用于软件的设置文件，比如笔者常用的Visual Studio Code和Microsoft Terminal;
以及客户端与服务器之间的通讯，比如C++的cppjsonrpc库。</p>
<h3 id="731-json%E5%9C%A8%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">7.3.1 JSON在设置文件中的应用</h3>
<h3 id="732-json%E5%9C%A8%E7%A8%8B%E5%BA%8Fapi%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">7.3.2 JSON在程序API设计中的应用</h3>
<h3 id="733-%E7%BC%96%E5%86%99minesweeper%E6%B8%B8%E6%88%8F%E7%9A%84json%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6">7.3.3 编写Minesweeper游戏的JSON设置文件</h3>
<h2 id="74-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regular-expression">7.4 正则表达式 Regular Expression</h2>
<h2 id="75-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">7.5 二维数组的深度优先搜索</h2>
<h2 id="76-minesweeper-%E6%B8%B8%E6%88%8F%E7%BC%96%E5%86%99">7.6 Minesweeper 游戏编写</h2>

</body>
</html>
