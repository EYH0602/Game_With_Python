<!DOCTYPE html>
<html>
<head>
<title>ms.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E7%AC%AC7%E7%AB%A0-minesweeper">第7章 Minesweeper</h1>
<p>前面几张已经介绍过Pygame模块的基本使用方法，本章将会把重点放在实现扫雷游戏的Python语法和算法。
在第6章 Connect 4中，我们介绍了矩阵（二维数组）的结构和基本算法，在这章则会接触矩阵的基本搜素算法。
除此之外，本章将会介绍一些在应用方便的基础知识，比如应用广泛的JSON文件和正则表达式</p>
<!---和匿名函数--->
<p>我们在Minesweeper游戏将要涉及的几个功能如下:</p>
<ul>
<li>元组</li>
<li>Pygame 通过鼠标的人机交互</li>
<li>文件处理</li>
<li>JSON文件</li>
<li>正则表达式 Regular Expression</li>
<li>二维数组的深度优先搜索</li>
</ul>
<!---* 匿名函数 Lambda Expression-->
<h2 id="71-%E5%85%83%E7%BB%84-tuple">7.1 元组 Tuple</h2>
<h3 id="711-tuple-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">7.1.1 Tuple 基本语法</h3>
<p>元组是一种常用的对象类型，很多高层编程语言都有它的身影。
在C++中他叫作pair或是set，在Java中它叫做Tuple。元组的作用其实很简单：表示一组<strong>相关的</strong>数据。
等等，表示一组数据？为什么这句话听起来与第6章学习的list如此相似？
是的，Tuple这种数据类型的应用场景和方式与list的确有很多相似的地方。来看看语法：</p>
<pre class="hljs"><code><div>fruit_tuple = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>) <span class="hljs-comment"># a tuple of fruits</span>
fruit_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]  <span class="hljs-comment"># a list of fruits</span>
</div></code></pre>
<p>Python作为一种高级语言，一个元组所包含的元素类型可以不一样, 也可以有多种创建方法。
在创建元组的时候，Python允许我们使用()来表示这组数据的类型为元组，就像[]表示一组数据为列表一样。
与此同时，Python同样允许我们不写()，同样表示元组。
然而，作者极其不推荐这种写法，因为很多时候这种创建方式的表达意义并不明确，会带来很差的可读性。
要时刻记住，写代码的首要目的是让人能看懂，其次才是让计算机运行</p>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-string">'apple'</span>, <span class="hljs-number">50</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-number">16.7</span>)    <span class="hljs-comment"># 包含不同类型的元素</span>
tup2 = <span class="hljs-string">'apple'</span>, <span class="hljs-number">50</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-number">16.7</span>      <span class="hljs-comment"># 不是使用()创建</span>
tup3 = ()   <span class="hljs-comment"># 创建空元组</span>
tup4 = (<span class="hljs-string">'delicious'</span>,)   <span class="hljs-comment"># 创建只有一个元素的元组，有逗号</span>
tup5 = (<span class="hljs-string">'delicious'</span>)    <span class="hljs-comment"># 创建只有一个元素的元组，无逗号</span>

print(tup1)
print(tup2)
print(tup3)
print(tup4)
print(tup5)
</div></code></pre>
<p>依次打印tup1-tup4, 看看这段代码的运行结果是什么。从运行结果可以看出，tup4和tup5的打印结果
有很大的区别。如果元素只有一个元素，请务必记住要在元素后加上都好','，否则Python解释器会把你的
意思理解为字符串，如同tup5的运行结果：</p>
<pre class="hljs"><code><div>('apple', 50, 'banana', 16.7)
('apple', 50, 'banana', 16.7)
()
('delicious',)
delicious
</div></code></pre>
<p>在了解如何创建元组后，我们需要做的就是访问元组。
访问元组元素的方式与列表类似，通过objName[index]的方式来表示元组中的元素。</p>
<pre class="hljs"><code><div>tup = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>) <span class="hljs-comment"># a tuple of fruits</span>
print(tup)
print(tup[<span class="hljs-number">0</span>])   <span class="hljs-comment"># apple</span>
print(tup[<span class="hljs-number">-2</span>])  <span class="hljs-comment"># orange</span>
print(tup[<span class="hljs-number">1</span>:])  <span class="hljs-comment"># ('banana', 'orange', 'peach')</span>

<span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> tup:
    print(fruit)
</div></code></pre>
<p>运行结果如下：</p>
<pre class="hljs"><code><div>('apple', 'banana', 'orange')
apple
orange
('banana', 'orange', 'peach')
apple
banana
orange
peach
</div></code></pre>
<p>除了简单的创建和访问之外，元组类还支持一些列的基础计算。
Python允许我们使用'+'操作符来合并两个元组，'*'操作符来复制元组的元素：</p>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>)
tup2 = (<span class="hljs-string">'b'</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>)
tup3 = tup1 + tup2
print(tup3) <span class="hljs-comment"># (1, 'a', 2, 'b', 3, 'c')</span>

tup4 = (<span class="hljs-string">'abc'</span>,)*<span class="hljs-number">3</span>
print(tup4) <span class="hljs-comment"># ('abc', 'abc', 'abc')</span>
</div></code></pre>
<p>元组最为Python的一个类，当然要有成员函数。
Python给元组类定义了五个最常用的成员函数：</p>
<ul>
<li>len(tuple)</li>
<li>max(tuple)</li>
<li>min(tuple)</li>
<li>tuple(list)</li>
</ul>
<pre class="hljs"><code><div>tup1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
list1 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]

print(len(tup1))    <span class="hljs-comment"># 3</span>
print(max(tup1))    <span class="hljs-comment"># 3</span>
print(min(tup1))    <span class="hljs-comment"># 1</span>
print(tuple(list1)) <span class="hljs-comment"># (4, 5, 6)</span>
</div></code></pre>
<h3 id="712-tuple%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB">7.1.2 Tuple与List的区别</h3>
<h5 id="1-%E5%8F%AF%E6%9B%B4%E6%94%B9%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9">1. 可更改与不可更改</h5>
<p>通过第6章所学，我们知道如何对列表的元素进行更新。然而，同样的更改在元组是不可行的。
什么意思呢？这就是列表和元组的第一大区别。
在列表类型中，元素的值是可以被更改的；而在元组类型中，元素的之是不可更改的。
因此，我们可以使用元组最为字典的key值，而列表不行。
为了更加直观的体现，让我们用代码尝试一下吧:<br>
列表：</p>
<pre class="hljs"><code><div>fruits = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>]
print(fruits)

fruits[<span class="hljs-number">1</span>] = <span class="hljs-string">'watermelon'</span> <span class="hljs-comment"># 更新fruits列表的第2位元素</span>
print(fruits)
</div></code></pre>
<p>运行结果如下：</p>
<pre class="hljs"><code><div>['apple', 'banana', 'orange', 'peach']
['apple', 'watermelon', 'orange', 'peach']
</div></code></pre>
<p>元组:</p>
<pre class="hljs"><code><div>fruits = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>)
fruits[<span class="hljs-number">1</span>] = <span class="hljs-string">'watermelon'</span> <span class="hljs-comment"># 尝试更新fruits元组的第2位元素</span>
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>Traceback (most recent call last):
  File &quot;try.py&quot;, line 4, in &lt;module&gt;
      fruits[1] = 'watermelon'
      TypeError: 'tuple' object does not support item assignment

      shell returned 1
</div></code></pre>
<p>很明显，Python解释器不允许我们这样做。它也给出了明显的提醒:
TypeError: 'tuple' object does not support item assignment.</p>
<p>不光是元组的元素不可更改，它的长度同样也是不可更改的。
Tuple类甚至都没有给出增加/减少元素的函数:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># continues from the last code block</span>
fruits.append(<span class="hljs-string">'kiwi'</span>)
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>Traceback (most recent call last):
  File &quot;try.py&quot;, line 3, in &lt;module&gt;
      fruits.append('kiwi')
      AttributeError: 'tuple' object has no attribute 'append'

      shell returned 1
</div></code></pre>
<h5 id="2-%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%95%E7%94%A8">2. 复制与引用</h5>
<p>在第6章中，我们学习过函数传递值和传递引用的区别。
同样的思想也在列表与元组的区别中有所体现。
因为元组类型的不可更改性，当你使用tuple(tup_name)函数进行类型转换是，返回值是原元组的引用。
而列表具有可更改该性，list(list_name)的返回值是被复制产生的新列表。</p>
<pre class="hljs"><code><div>fruit_tuple = (<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>) <span class="hljs-comment"># a tuple of fruits</span>
fruit_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]  <span class="hljs-comment"># a list of fruits</span>

<span class="hljs-comment"># test for tuple</span>
tuple2 = tuple(fruit_tuple)
print(tuple2 <span class="hljs-keyword">is</span> fruit_tuple)

<span class="hljs-comment"># test for list</span>
list2 = list(fruit_list)
print(list2 <span class="hljs-keyword">is</span> fruit_list)
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>True
False
</div></code></pre>
<h5 id="3-%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8">3. 空间占用</h5>
<p>由于元组类型的不可能改性，Python解释器会为其分配更小的内存占用。
因此，当元组和列表包含通函的元素时，元组占用的空间会更小一些。</p>
<pre class="hljs"><code><div><span class="hljs-comment"># continues from the last code block</span>
print(fruit_tuple.__sizeof__())
print(fruit_list.__sizeof__())
</div></code></pre>
<p>运行结果如下:</p>
<pre class="hljs"><code><div>48
64
</div></code></pre>
<p>综上所述，我们在编写程序时，根据需求来选择使用元组或者列表。
如果无需更改内容，或者需要使内容不可更改，我们会选择使用元组。
比如传递游戏屏幕上的坐标，使用一种颜色，等等。
而当我们需要对内容进行更改是，我们只能选择列表。
比如游戏棋盘。</p>
<h2 id="72-pygame-%E9%80%9A%E8%BF%87%E9%BC%A0%E6%A0%87%E7%9A%84%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92">7.2 Pygame 通过鼠标的人机交互</h2>
<p>在上一章，我们学习了Pygame模块的基础功能，比如设置游戏屏幕，键盘交互，绘制图形等。
在这一章，因为扫雷不能用只用键盘来玩，我们将要学习如何通过鼠标点击与计算机交互。
在讨论通过鼠标的Pygame人机交互以前，我们先来认识一下常规鼠标的构造。</p>
<img src="pics/Logitech%20M325.jpeg" alt="Logitech M325" width="150" height="150"/>
<p>从图片可以看出，普通鼠标的正面（上面）有三个按键。从左到右，把它们标号为1,2,3。</p>
<table>
<thead>
<tr>
<th>键位</th>
<th>代号</th>
</tr>
</thead>
<tbody>
<tr>
<td>左键</td>
<td># 1</td>
</tr>
<tr>
<td>滚轮键</td>
<td># 2</td>
</tr>
<tr>
<td>右键</td>
<td># 3</td>
</tr>
</tbody>
</table>
<p>为什么要定义这三个常用按键的代号呢？因为我们在Pygame中就是以这三个代号称呼他们的
在扫雷游戏中，我们需要用到鼠标的左键和右键，也就是1和3。在取得鼠标信息的过程中，
需要注意到的Pygame功能有2点:</p>
<ul>
<li>pygame.MOUSEBUTTONUP</li>
<li>pygame.mouse.get_pos()</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># 首先定义左键和右键，使得代码可读性更高</span>
LEFT = <span class="hljs-number">1</span>
RIGHT = <span class="hljs-number">3</span>

<span class="hljs-comment"># 引用第6章中获取状态的代码</span>
<span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():
	pos = pygame.mouse.get_pos()
	print(pos)	<span class="hljs-comment"># 打印鼠标点击在游戏屏幕上的坐标</span>
	<span class="hljs-keyword">if</span> event.button == LEFT:
		print(<span class="hljs-string">"Left Click"</span>)
	<span class="hljs-keyword">elif</span> event.button == RIGHT:
		print(<span class="hljs-string">"Right Click"</span>)
</div></code></pre>
<h2 id="73-json">7.3 JSON</h2>
<p>JSON全称叫做JavaScript Object Notation，是一种面对对象的通用表示方法。
JSON这种表示方法具备什么样的特性呢？</p>
<ul>
<li>轻量级<br>
JSON文件本质是文本文件，占用极小的储存空间，读取时占用内存很小</li>
<li>易懂<br>
JSON文件格式可以很好的描述面对对象的程序设计理念，更加直观的说明程序设计API</li>
<li>独立于编程语言<br>
尽管JSON叫做JavaScript Object Notation，但其实并非只能用于JavaScript。
大多数流行的编程语言都有自己的JSON处理模块，
比如Python的json模块，C++的Json::Value库</li>
</ul>
<p>由于这三个特性，JSON经常被用于软件的设置文件，比如笔者常用的Visual Studio Code和Microsoft Terminal;
以及客户端与服务器之间的通讯，比如C++的jsoncpprpc库。</p>
<h3 id="731-json%E8%AF%AD%E6%B3%95">7.3.1 JSON语法</h3>
<p>JSON文件有至少组key-value pair组成。
其中的key指一个对象的名字，它必须是字符串。
其中的value值对象的值，它可以使任何类型。
如果value是不同类型，我们直接写出它就行。
如果value是列表，我们需要把元素写在[]中，与Python一样。
如果value是一个对象，我们需要把它写在{}中。</p>
<p>如果JSON包含多组key-value pair的话，我们需要用','将他们分隔开。
最后一组key-value pair后面不能有','。
下面会展示一个例子，使用JSON来描述一个课程。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// course.json</span>
{
	<span class="hljs-attr">"name"</span>: <span class="hljs-string">"Python Programming in Games"</span>,
	<span class="hljs-attr">"id"</span>: <span class="hljs-string">"123456"</span>,
	<span class="hljs-attr">"chapters"</span>: [
		<span class="hljs-comment">// ...</span>
		<span class="hljs-string">"chapter 6"</span>: <span class="hljs-string">"Connect 4"</span>,
		<span class="hljs-string">"chapter 7"</span>: <span class="hljs-string">"Minesweeper"</span>
		<span class="hljs-comment">// .. many more chapters</span>
	],
	<span class="hljs-attr">"this chapter"</span>: {
		<span class="hljs-attr">"number"</span>: <span class="hljs-number">7</span>,
		<span class="hljs-attr">"name"</span>: <span class="hljs-string">"Minesweeper"</span>,
		<span class="hljs-attr">"subsections"</span>: [
			<span class="hljs-string">"7.1"</span>: <span class="hljs-string">"Tuple"</span>,
			<span class="hljs-string">"7.2"</span>: <span class="hljs-string">"JSON"</span>,
			<span class="hljs-string">"7.3"</span>: <span class="hljs-string">"Regular Expression"</span>,
			<span class="hljs-string">"7.4"</span>: <span class="hljs-string">"DFS in 2D Array"</span>,
			<span class="hljs-string">"7.5"</span>: <span class="hljs-string">"Minesweeper Program"</span>
		]
	}
}
</div></code></pre>
<p>这段JSON所表示的对面在Python是如何体现的呢？</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, number, name, subsections)</span>:</span>
        <span class="hljs-comment"># number: int, name: string, subsections: List[string]</span>
        self.chapNumber = number
        self.name = name
        self.subsections = subsections;
        
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, courseID, chapters, thisChapter)</span>:</span>
        <span class="hljs-comment"># name: string, courseID: string, chapters: List[string], thisChapter: Chapter</span>
        self.name = name
        self.courseID = courseID
        self.chapters = chapters
        self.thisChapter = thisChapter

thisChapter = Chapter(<span class="hljs-number">7</span>, <span class="hljs-string">'Minesweeper'</span>,
                    [<span class="hljs-string">'Tuple'</span>, <span class="hljs-string">'JSON'</span>, <span class="hljs-string">'Regular Expression'</span>, \
                    <span class="hljs-string">'DFS in 2D Array'</span>, <span class="hljs-string">'Minesweeper Program'</span>])

thisCourse = Course(<span class="hljs-string">'Python Programming in Games'</span>, <span class="hljs-string">'123456'</span>, \
                    [..., <span class="hljs-string">'Connect 4'</span>, <span class="hljs-string">'Minesweeper'</span>, ...], \
                    thisChapter)
</div></code></pre>
<h3 id="732-json%E5%9C%A8%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">7.3.2 JSON在设置文件中的应用</h3>
<p>在这个小结，我们将阅读Windows Terminal设置文件用的一个节选片段。
然后解释这个设置文件中每组key-value pair的意义。解释见代码注释。</p>
<pre class="hljs"><code><div>{
	<span class="hljs-comment">// Add custom color schemes to this array.</span>
    <span class="hljs-comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span>
	<span class="hljs-attr">"scheme"</span>:
	[
		{
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Breeze"</span>,
            <span class="hljs-attr">"black"</span>: <span class="hljs-string">"#12181d"</span>,	<span class="hljs-comment">// a color in rgb hexadecimal format</span>
            <span class="hljs-attr">"red"</span>: <span class="hljs-string">"#eb5b5b"</span>,
            <span class="hljs-attr">"green"</span>: <span class="hljs-string">"#bfeea4"</span>,
            <span class="hljs-attr">"yellow"</span>: <span class="hljs-string">"#fc8162"</span>,
            <span class="hljs-attr">"blue"</span>: <span class="hljs-string">"#6eb7eb"</span>,
            <span class="hljs-attr">"purple"</span>: <span class="hljs-string">"#9b59b6"</span>,
            <span class="hljs-attr">"cyan"</span>: <span class="hljs-string">"#1abc9c"</span>,
            <span class="hljs-attr">"white"</span>: <span class="hljs-string">"#eff0f1"</span>,
            <span class="hljs-attr">"brightBlack"</span>: <span class="hljs-string">"#d8e3e4"</span>,
            <span class="hljs-attr">"brightRed"</span>: <span class="hljs-string">"#c0392b"</span>,
            <span class="hljs-attr">"brightGreen"</span>: <span class="hljs-string">"#1cdc9a"</span>,
            <span class="hljs-attr">"brightYellow"</span>: <span class="hljs-string">"#fdbc4b"</span>,
            <span class="hljs-attr">"brightBlue"</span>: <span class="hljs-string">"#3daee9"</span>,
            <span class="hljs-attr">"brightPurple"</span>: <span class="hljs-string">"#57b4df"</span>,
            <span class="hljs-attr">"brightCyan"</span>: <span class="hljs-string">"#62dd69"</span>,
            <span class="hljs-attr">"brightWhite"</span>: <span class="hljs-string">"#fcfcfc"</span>,
            <span class="hljs-attr">"background"</span>: <span class="hljs-string">"#31363b"</span>,
            <span class="hljs-attr">"foreground"</span>: <span class="hljs-string">"#eff0f1"</span>
        }
	],

	<span class="hljs-comment">// Add custom keybindings to this array.</span>
    <span class="hljs-comment">// To unbind a key combination from your defaults.json, set the command to "unbound".</span>
    <span class="hljs-comment">// To learn more about keybindings, visit https://aka.ms/terminal-keybindings</span>
	<span class="hljs-attr">"keybindings"</span>:
	[
		<span class="hljs-comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span>
        <span class="hljs-comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span>
        <span class="hljs-comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span>
        { <span class="hljs-attr">"command"</span>: {<span class="hljs-attr">"action"</span>: <span class="hljs-string">"copy"</span>, <span class="hljs-attr">"singleLine"</span>: <span class="hljs-literal">false</span> }, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+c"</span> },
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"paste"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+v"</span> },

        <span class="hljs-comment">// Press Ctrl+Shift+F to open the search box</span>
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"find"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+shift+f"</span> },

        <span class="hljs-comment">// Press ctrl+shift+. to open a new pane.</span>
        <span class="hljs-comment">// - "split": "auto" makes this pane open in the direction that provides the most surface area.</span>
        <span class="hljs-comment">// - "splitMode": "duplicate" makes the new pane use the focused pane's profile.</span>
        <span class="hljs-comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span>
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"splitPane"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+shift+."</span> },
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"closePane"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+shift+,"</span>},
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"newTab"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+shift+a"</span> },
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"closeTab"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+shift+z"</span>},
        { <span class="hljs-attr">"command"</span>: <span class="hljs-string">"nextTab"</span>, <span class="hljs-attr">"keys"</span>: <span class="hljs-string">"ctrl+tab"</span> }
	]
}
</div></code></pre>
<h3 id="733-%E7%BC%96%E5%86%99minesweeper%E6%B8%B8%E6%88%8F%E7%9A%84json%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6">7.3.3 编写Minesweeper游戏的JSON设置文件</h3>
<p>了解完JSON文件的写法和作用后，我们就需要动手设计Minesweeper游戏的设置文件啦。
在开始编写之前，要首先搞清楚游戏的基础设计:</p>
<ol>
<li>游戏屏幕为一个正方向，我们需要size代表游戏屏幕的宽度和高度</li>
<li>地雷数量。拥有两种模式:
<ol>
<li>如果地雷数量是一个整数，则设置这么多地雷</li>
<li>如果地雷数量是default，游戏将会根据size和level自行计算地雷数量</li>
</ol>
</li>
<li>因为2.2，我们需要level</li>
<li>颜色设置
<ul>
<li>游戏屏幕的背景颜色</li>
<li>地雷被引爆后的颜色</li>
<li>以证实为安全地区的颜色</li>
<li>右键插的旗子颜色</li>
<li>文字(数字)的颜色</li>
</ul>
</li>
<li>字体
<ul>
<li>数字的字体</li>
<li>游戏结束后弹出屏幕的字体</li>
</ul>
</li>
<li>玩家的昵称</li>
</ol>
<p>在开始编写JSON配置文件之前，我们还需要知道Pygame模块都支持哪些字体。
我们可以通过指令行来获取这些字体的名称，在这里以Linux环境下bash举例:</p>
<pre class="hljs"><code><div>$ python3 &gt; pygameFonts.txt
Python 3.8.2 (default, Apr 27 2020, 15:53:34) 
[GCC 9.3.0] on linux
Type <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> or <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.
&gt;&gt;&gt; import pygame
pygame 1.9.6
Hello from the pygame community. https://www.pygame.org/contribute.html
&gt;&gt;&gt; pygame.init()
&gt;&gt;&gt; <span class="hljs-built_in">print</span>(pygame.font.get_fonts())
</div></code></pre>
<p>然后查看pygameFonts.txt文件就可以知道哪些字体可以使用了。
接着根据获取到的字体编写JSON设置文件，setting.json:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"size"</span>: <span class="hljs-number">15</span>,
    <span class="hljs-attr">"number of mine"</span>: <span class="hljs-string">"default"</span>, 
    <span class="hljs-attr">"level"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">"color"</span>: {
        <span class="hljs-attr">"background"</span>: <span class="hljs-string">"#cd5c5c"</span>,
        <span class="hljs-attr">"boom"</span>: <span class="hljs-string">"#e74c3c"</span>,
        <span class="hljs-attr">"revealed_blank"</span>: <span class="hljs-string">"#eaeded"</span>,
        <span class="hljs-attr">"flag"</span>: <span class="hljs-string">"#5b2c6f"</span>,
        <span class="hljs-attr">"text"</span>: <span class="hljs-string">"#000000"</span>
    },
    <span class="hljs-attr">"font"</span>: {
        <span class="hljs-attr">"number_font"</span>: <span class="hljs-string">"arialblack"</span>,
        <span class="hljs-attr">"text_font"</span>: <span class="hljs-string">"lucidaconsole"</span>
    },
    <span class="hljs-attr">"player"</span>: <span class="hljs-string">"EEEH"</span>
}
</div></code></pre>
<h3 id="734-python%E4%B8%AD%E7%9A%84json%E6%A8%A1%E5%9D%97">7.3.4 Python中的json模块</h3>
<p>json模块的初步运用其实很简单，只需要遵循一下一个步骤:</p>
<ol>
<li>打开setting.json文件</li>
<li>根据setting.json文件创建json对象</li>
<li>根据key读取需要的value</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment"># functions.py</span>
<span class="hljs-keyword">import</span> json

<span class="hljs-comment"># load setting</span>
settingFile = open(<span class="hljs-string">"settings.json"</span>)
setting = json.load(settingFile)

<span class="hljs-comment"># read values based on key-value pair </span>
boomColor = setting[<span class="hljs-string">"color"</span>][<span class="hljs-string">"boom"</span>]
blankColor = setting[<span class="hljs-string">"color"</span>][<span class="hljs-string">"revealed_blank"</span>]
flagColor = setting[<span class="hljs-string">"color"</span>][<span class="hljs-string">"flag"</span>]
numFont = setting[<span class="hljs-string">"font"</span>][<span class="hljs-string">"number_font"</span>]
size = setting[<span class="hljs-string">"size"</span>]

<span class="hljs-comment"># print variables out to see the result</span>
print(boomColor)
print(blankColor)
print(flagColor)
print(numFont)
print(size)
</div></code></pre>
<p>运行结果:</p>
<pre class="hljs"><code><div>#e74c3c
#eaeded
#5b2c6f
arialblack
15
</div></code></pre>
<h2 id="74-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regular-expression">7.4 正则表达式 Regular Expression</h2>
<p><em>正则表达式</em>是用于表示文本规律的一种符号标记。
正则表达式使用符号来描述语言，起到具有规律匹配的功能。
在很多常用的文本编辑器中，都存在使用正则表达式的搜索匹配方式。
很多常用的指令工具同样支持正则表达式
比如常用的ls(<em>list</em>)和grep(<em><strong>g</strong>lobal <strong>r</strong>gular <strong>e</strong>xpression <strong>p</strong>rint</em>)
多数常用的编程语言同样支持正则表达式的表示方法。
比如C++的&lt;regex&gt;库，Python的re模块，和Java的java.util.regex。
函数式编程语言Perl甚至内建了对正则表达式的支持。
不过正则表达式在这些不同编程语言的库中，语法可能略有不同。
所以在使用不同语言的正则库前最后先看一下官方文档。
在这章的讲解中，7.4.1 数据搜索将使用POSIX标准的正则表达式；
而7.4.2 re模块将以Python的官方文档为准。</p>
<h3 id="741-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%94%A8%E6%B3%95-%E6%95%B0%E6%8D%AE%E6%90%9C%E7%B4%A2grep">7.4.1 正则表达式的用法: 数据搜索(grep)</h3>
<p><em>注: 本小节以bash为标准</em><br>
在指令行，最经常与正则表达式一起使用的软件是grep。
根据grep的全称global regular expression print，可以清晰看出它与正则表达式关系密切。
grep的功能就是根据正则表达式在一个或多个文件中进行搜索，然后以标准输出展示搜索结果。<br>
根据grep的manual文档，看一看它的主要使用方法</p>
<pre class="hljs"><code><div>$ man grep
GREP(1)                                                               User Commands

NAME
       grep, egrep, fgrep, rgrep - <span class="hljs-built_in">print</span> lines that match patterns

SYNOPSIS
       grep [OPTION...] PATTERNS [FILE...]
        ...

DESCRIPTION
    ...
</div></code></pre>
<p>在Synopsis一栏的第一行写出了grep的主要用法。
这个PATTERNS代表的就是正则表达式。
正如前文所言，正则表达式起到具有规律匹配的功能。<br>
在了解了grep程序后，是时候知道如何使用正则表达式与grep配合进行搜索了。
接下来，我们将会看看如何使用正则表达是的符号来代表文本</p>
<h4 id="%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6">‘任意’字符</h4>
<p>正则表达式中最常用的符号就是'.'符号，也称英文的句号，就是所谓的‘任意’字符。
'.'符合可以匹配ASCII中的任意字符。
假设有一个叫做&quot;abc.txt&quot;的文档,
<code>grep &quot;.abc&quot; abc.txt</code>的作用就是在abc.txt这个文档中搜索所用匹配正则表达式<code>.abc</code>的行。</p>
<pre class="hljs"><code><div>$ cat abc.txt
1abc
2abc
3aac
4cca
5abc
6aabc
$ grep <span class="hljs-string">".abc"</span> acb.txt
1abc
2abc
5abc
6aabc
</div></code></pre>
<h4 id="%E5%AE%9A%E6%80%A7%E5%AD%97%E7%AC%A6">定性字符</h4>
<p>正则表达是中使用'^'和'$'作为定性字符。
'^'表示这个正则表达式必须出现在一行的最开始。
'$'表示这个这则表达是必须出现在一行的最后。</p>
<pre class="hljs"><code><div>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"ccaaac"</span> &gt;&gt; abc.txt
$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"bacaac"</span> &gt;&gt; abc.txt
$ grep <span class="hljs-string">"abc$"</span> abc.txt
1abc
2abc
5abc
6aabc
$ grep <span class="hljs-string">"^abc"</span> abc.txt
</div></code></pre>
<p>可以看出，<code>grep &quot;abc$&quot; abc.txt</code>可以帮我们找出abc.txt中所有以&quot;abc&quot;结尾的行。
而在执行<code>grep &quot;^abc&quot; abc.txt</code>时，grep会搜索abc.txt中所以&quot;abc&quot;开始的行。
因为abc.txt文件中名没有以&quot;abc&quot;开始的行，所以没有标准输出的搜索结果。
如果我们查看一下这次运行grep的返回值，会发现是1，表示失败。</p>
<pre class="hljs"><code><div>$ <span class="hljs-built_in">echo</span> $?
1
</div></code></pre>
<h4 id="%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95">括号表示法</h4>
<p>我们也可以用这则表达是的括号表示法来达到匹配的目的。
在正则表达式中，一组[]表示一个字符。
而[]里面的内容表示这个括号可以有的选项。</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"[ca$]"</span> abc.txt
1abc
2abc
3aac
4cca
5abc
6aabc
ccaaac
bacaac
</div></code></pre>
<p>如你所见，<code>grep &quot;[ca$]&quot; abc.txt</code>可以找出abc.txt文件中所有以a字符或者c字符结尾的行。
我们再来看一个搜索范围更加精确的例子</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"[bc]a$"</span> abc.txt
4cca
</div></code></pre>
<p>这次的搜索只有一个匹配了。
因为<code>&quot;[bc]a$&quot;</code>仅可以匹配abc.txt中&quot;ba&quot;或者&quot;ca&quot;结尾的行。</p>
<h4 id="%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</h4>
<p>正则表达式同样支持按照字符类型进行匹配。
假设我们需要搜索abc.txt中所有以数字开头的行，按照普通的括号表示法该如何表示呢？
如果只用普通的括号表示法，我们需要在[]中写出0-9所有的数字字符，来达到匹配数字的目的。</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"^[1234567890]"</span> abc.txt
1abc
2abc
3aac
4cca
5abc
6aabc
$ grep <span class="hljs-string">"^[1234567890]abc"</span> abc.txt
1abc
2abc
5abc
</div></code></pre>
<p>但这样做实在是太麻烦了。
使用正则表达式的目的是快速方便的匹配内容，而不是给自己找麻烦。
因此我们可以使用正则表达式字符类型功能。
在正则表达式中，<code>[0-9]</code>代表数字类型，可以用来代替<code>[0123456789]</code>。
可以看出，这样的正则表达式效果是一样的。</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"^[0-9]"</span> abc.txt
1abc
2abc
3aac
4cca
5abc
6aabc
$ grep <span class="hljs-string">"^[0-9]abc"</span> abc.txt
1abc
2abc
5abc
</div></code></pre>
<p>除了<code>[0-9]</code>表示全体数字字符之外，类型表达法还可以遵从自定义的区间。
比如<code>[0-3]</code>就可以表0,1,2,3这四个数字字符。</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"^[0-3]abc"</span> abc.txt
1abc
2abc
</div></code></pre>
<p>除了数字类型的字符可以用这种方式来表示外，字母类型也是可以的。
在正则表达式中，<code>[a-z]</code>用于表示小写字母。
<code>[A-Z]</code>用于表示大写字母。</p>
<pre class="hljs"><code><div>$ cat 123.txt
a123
b123
c345
d567
lxyz
f555

A123
B123
C345
D567
Lxyz
F555
$ grep <span class="hljs-string">"^[a-z]"</span> 123.txt
a123
b123
c345
d567
lxyz
f555
$ grep <span class="hljs-string">"^[A-Z]"</span> 123.txt
A123
B123
C345
D567
Lxyz
F555
</div></code></pre>
<p>从例子中可以看出，<code>^[a-z]</code>可以比配123.txt中所有以小写字母开头的行。
而<code>^[A-Z]</code>则可以匹配123.txt中所有以大写字母开头的行。<br>
现在我们知道如何用正则表达式来表示小写字母和大写字母了。
但感觉表示全体字母的时候还是有些麻烦。
有没有什么办法可以进行无视大小写的匹配呢?</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"^[a-Z]"</span> 123.txt
a123
b123
c345
d567
lxyz
f555
A123
B123
C345
D567
Lxyz
F555
</div></code></pre>
<p>答案是可以的。正则表达式支持通过<code>[a-Z]</code>来表示全体字母字符。
但是反过来<code>[A-z]</code>就不行了。</p>
<pre class="hljs"><code><div>$ grep <span class="hljs-string">"^[A-z]"</span> 123.txt
$ <span class="hljs-built_in">echo</span> $?
2
</div></code></pre>
<h4 id="%E9%87%8F%E8%AF%8D">量词</h4>
<p>我们都知道什么是量词：用于表示数量的词语。
在任何一种语言的写作中，量词都是不可缺少的。
在正则表达式中也是存在量词的。并且，正则表达式存在多种量词的表示方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">意义 (匹配前一字符...)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">0次或1次</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">0次或多次</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">1次或多次</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:left">n次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:left">至少n次，最多m次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:left">至少n次</td>
</tr>
<tr>
<td style="text-align:center">{,m}</td>
<td style="text-align:left">最多m次</td>
</tr>
</tbody>
</table>
<p>由此可见，通过正则表达式的语法，我们可以达成多种多样的自由搜索。
在处理文本数据的时候，正则表达式可以极高的提高我们的工作效率。
grep搜索也支持一种POSIX表示法。
POSIX式一种更高级的字符类型表示方法。
由于Python的re模块不支持POSIX，这里不做讲解。</p>
<h3 id="742-python%E7%9A%84re%E6%A8%A1%E5%9D%97">7.4.2 Python的re模块</h3>
<p>Python的re模块允许我们根据正则表达式来跟字符串进行比较。
re模块所使用的正则表达式语法跟7.4.1所讲的grep区别不大。
grep支持的正则表达式可以直接在Python的re模块使用。</p>
<h4 id="findallpattern-str-text-str---liststr">findall(pattern: str, text: str) -&gt; List[str]</h4>
<p><code>findall()</code>函数可以找到一个字符串中所有与正则表达式匹配的<strong>子字符串</strong>。
<code>findall()</code>可以找出text中所有匹配的子字符串，然后以列表形式返回搜索结果。
如果没有找到可以匹配的搜索结果，<code>findall()</code>会返回一个空的列表。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> re

text = <span class="hljs-string">"1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac"</span>
res = re.findall(<span class="hljs-string">"[0-9]abc"</span>, text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>['1abc', '2abc', '5abc']
</div></code></pre>
<p>如果我们稍微改动一点pattern，运行结果就会有所不同。
因为Python的<code>findall()</code>函数是对<strong>子字符串</strong>进行匹配，而非像grep按<strong>行</strong>进行匹配</p>
<pre class="hljs"><code><div>res = re.findall(<span class="hljs-string">"[0-9]a"</span>, text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>['1a', '2a', '3a', '5a', '6a']
</div></code></pre>
<p>如果要是找不到可以匹配的子字符串，<code>findall()</code>就会返回一个空列表。</p>
<pre class="hljs"><code><div>res = re.findall(<span class="hljs-string">"^[a-z]"</span>, text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>[]
</div></code></pre>
<h4 id="searchpattern-str-text-str---match">search(pattern: str, text: str) -&gt; match</h4>
<p><code>search()</code>函数可以找到text中的所有的匹配的<strong>第一个</strong>子字符串，
并把找到的结果作为一个 <strong>Match object(匹配对象)</strong> 返回。
虽然<code>search()</code>的功能看起来和<code>findall()</code>很像，但还是有本质去别的。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> re
text = <span class="hljs-string">"1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac"</span>
res = re.search(<span class="hljs-string">"[0-9]a"</span>, text)
print(res)
</div></code></pre>
<p>运行结果：</p>
<pre class="hljs"><code><div>&lt;re.Match object; span=(0, 2), match='1a'&gt;
</div></code></pre>
<p>拿到这个搜索结果后，我们可以对它进行几个操作</p>
<pre class="hljs"><code><div>print(res.span())
print(res.group())
print(res.string)
</div></code></pre>
<p>运行结果：</p>
<pre class="hljs"><code><div>(0, 2)
1a
1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac
</div></code></pre>
<p>可以看出，<code>.span()</code>的返回值是一个元组，他代表搜索结果的(开始位置，结束位置)。
<code>.group()</code>则是可以取出这个匹配结果到底是什么子字符串，对应匹配对象的'match'。
<code>.string</code>的作用是查看原字符串。</p>
<h4 id="splitpattern-str-text-str-maxsplit0---liststr">split(pattern: str, text: str, maxsplit=0) -&gt; List[str]</h4>
<p><code>split()</code>函数可以根据正则表达式，把text分裂成一个列表。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> re
text = <span class="hljs-string">"1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac"</span>
res = re.split(<span class="hljs-string">" "</span>, text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>['1abc', '2abc', '3aac', '4cca', '5abc', '6aabc', 'ccaaac', 'bacaac']
</div></code></pre>
<p><code>re.split(&quot; &quot;, text)</code>把text这个字符串，从每个<code>&quot; &quot;</code>分开，以一个列表的形式返回。
如果我们不需要把字符串分割成这么多分怎么办呢？这时候就需要给<code>split()</code>在传递一个maxsplit参数了。
如果我们不传maxsplit参数的话，<code>split()</code>默认把字符串尽可能多的分割。
而如果我们传递这个参数了的话，<code>split()</code>就会按照我们传递的参数进行分割了。
如果<code>maxsplit = 1</code>的话，意思式只在第一次搜索结果进行分割。
如果<code>maxsplit = 2</code>的话，意思是在第一次和第二次搜索结果的地方进行分割。其他数字以此类推。</p>
<pre class="hljs"><code><div>res = re.split(<span class="hljs-string">" "</span>, text, <span class="hljs-number">1</span>)
print(res)
res = re.split(<span class="hljs-string">" "</span>, text, <span class="hljs-number">2</span>)
print(res)
res = re.split(<span class="hljs-string">" "</span>, text, <span class="hljs-number">3</span>)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>['1abc', '2abc 3aac 4cca 5abc 6aabc ccaaac bacaac']
['1abc', '2abc', '3aac 4cca 5abc 6aabc ccaaac bacaac']
['1abc', '2abc', '3aac', '4cca 5abc 6aabc ccaaac bacaac']
</div></code></pre>
<p>然后看看基于正则表达式的替换效果怎么样:</p>
<pre class="hljs"><code><div>res = re.split(<span class="hljs-string">"a[bc]"</span>, text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>['1', 'c 2', 'c 3a', ' 4cca 5', 'c 6a', 'c ccaa', ' b', 'a', '']
</div></code></pre>
<h4 id="subpatter-str-repl-str-text-str-count0">sub(patter: str, repl: str, text: str, count=0)</h4>
<p><code>sub()</code>函数用于替换文本内容。
这个函数会根据pattern实在text中搜索，并且把匹配项替换成repl的。
我们用<code>sub()</code>函数把文件中所有的<code>&quot; &quot;</code>替换成<code>&quot;-&quot;</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> re
text = <span class="hljs-string">"1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac"</span>
res = re.sub(<span class="hljs-string">" "</span>, <span class="hljs-string">"-"</span>, text)
print(text)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac
1abc-2abc-3aac-4cca-5abc-6aabc-ccaaac-bacaac
</div></code></pre>
<p>与<code>split()</code>类似，<code>sub()</code>也允许我们传入一个count参数。
count参数的作用式告诉<code>sub()</code>我们想要替换多少个匹配项，如果不穿这个参数的话，默认为替换所有的匹配项。</p>
<pre class="hljs"><code><div>print(text)
res = re.sub(<span class="hljs-string">" "</span>, <span class="hljs-string">"*"</span>, text, <span class="hljs-number">1</span>)
print(res)
res = re.sub(<span class="hljs-string">" "</span>, <span class="hljs-string">"*"</span>, text, <span class="hljs-number">2</span>)
print(res)
res = re.sub(<span class="hljs-string">" "</span>, <span class="hljs-string">"*"</span>, text, <span class="hljs-number">4</span>)
print(res)
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac
1abc*2abc 3aac 4cca 5abc 6aabc ccaaac bacaac
1abc*2abc*3aac 4cca 5abc 6aabc ccaaac bacaac
1abc*2abc*3aac*4cca*5abc 6aabc ccaaac bacaac
</div></code></pre>
<p>同样进行一次基于正则表达式的替换</p>
<pre class="hljs"><code><div>text = <span class="hljs-string">"1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac"</span>
res = re.sub(<span class="hljs-string">"a[bc]"</span>, <span class="hljs-string">"*"</span>, text)
print(text)
print(res)
</div></code></pre>
<p>运行结果:</p>
<pre class="hljs"><code><div>1abc 2abc 3aac 4cca 5abc 6aabc ccaaac bacaac
1*c 2*c 3a* 4cca 5*c 6a*c ccaa* b*a*
</div></code></pre>
<h2 id="75-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">7.5 二维数组的深度优先搜索</h2>
<h2 id="76-minesweeper-%E6%B8%B8%E6%88%8F%E7%BC%96%E5%86%99">7.6 Minesweeper 游戏编写</h2>

</body>
</html>
